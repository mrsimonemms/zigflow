"use strict";(globalThis.webpackChunkzigflow=globalThis.webpackChunkzigflow||[]).push([[9079],{1121(e,t,n){n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"dsl/tasks/listen","title":"Listen","description":"Provides a mechanism for workflows to await and react to external events, enabling","source":"@site/docs/dsl/tasks/listen.md","sourceDirName":"dsl/tasks","slug":"/dsl/tasks/listen","permalink":"/preview/main/docs/dsl/tasks/listen","draft":false,"unlisted":false,"editUrl":"https://github.com/mrsimonemms/zigflow/tree/main/docs/docs/dsl/tasks/listen.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dslSidebar","previous":{"title":"Fork","permalink":"/preview/main/docs/dsl/tasks/fork"},"next":{"title":"Raise","permalink":"/preview/main/docs/dsl/tasks/raise"}}');var r=n(4848),i=n(8453);const l={},d="Listen",a={},o=[{value:"Properties",id:"listen-properties",level:2},{value:"Event Consumption Strategy",id:"event-consumption-strategy",level:3},{value:"Properties",id:"event-consumption-strategy-properties",level:4},{value:"Event Filter",id:"event-filter",level:3},{value:"Properties",id:"event-filter-properties",level:4},{value:"Event Properties",id:"event-properties",level:3},{value:"Properties",id:"event-properties-properties",level:4},{value:"Query",id:"query",level:2},{value:"Example",id:"query-example",level:3},{value:"Signal",id:"signal",level:2},{value:"Example",id:"signal-example",level:3},{value:"Update",id:"update",level:2},{value:"Example",id:"update-example",level:3}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"listen",children:"Listen"})}),"\n",(0,r.jsxs)(t.p,{children:["Provides a mechanism for workflows to await and react to external events, enabling\nevent-driven behavior within workflow systems. In Temporal, there are\n",(0,r.jsx)(t.a,{href:"https://docs.temporal.io/handling-messages#writing-signal-handlers",children:"three methods"}),"\nthat can be used:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#query",children:"Query"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#signal",children:"Signal"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#update",children:"Update"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"listen-properties",children:"Properties"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Type"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Required"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"listen.to"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.a,{href:"#event-consumption-strategy",children:(0,r.jsx)(t.code,{children:"eventConsumptionStrategy"})})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"yes"})}),(0,r.jsxs)(t.td,{children:["Configures the ",(0,r.jsx)(t.a,{href:"https://cloudevents.io/",children:"event(s)"})," the workflow must listen to."]})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"event-consumption-strategy",children:"Event Consumption Strategy"}),"\n",(0,r.jsx)(t.p,{children:"Represents the configuration of an event consumption strategy."}),"\n",(0,r.jsx)(t.h4,{id:"event-consumption-strategy-properties",children:"Properties"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Type"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Required"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"all"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.a,{href:"#event-filter",children:(0,r.jsx)(t.code,{children:"eventFilter[]"})})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"no"})}),(0,r.jsxs)(t.td,{children:["Configures the workflow to wait for all defined events before resuming execution.",(0,r.jsx)("br",{}),(0,r.jsxs)(t.em,{children:["Required if ",(0,r.jsx)(t.code,{children:"any"})," and ",(0,r.jsx)(t.code,{children:"one"})," have not been set."]})]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"any"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.a,{href:"#event-filter",children:(0,r.jsx)(t.code,{children:"eventFilter[]"})})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"no"})}),(0,r.jsxs)(t.td,{children:["Configures the workflow to wait for any of the defined events before resuming execution.",(0,r.jsx)("br",{}),(0,r.jsxs)(t.em,{children:["Required if ",(0,r.jsx)(t.code,{children:"all"})," and ",(0,r.jsx)(t.code,{children:"one"})," have not been set."]}),(0,r.jsx)("br",{}),(0,r.jsx)(t.em,{children:"If empty, listens to all incoming events"})]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"one"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.a,{href:"#event-filter",children:(0,r.jsx)(t.code,{children:"eventFilter"})})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"no"})}),(0,r.jsxs)(t.td,{children:["Configures the workflow to wait for the defined event before resuming execution.",(0,r.jsx)("br",{}),(0,r.jsxs)(t.em,{children:["Required if ",(0,r.jsx)(t.code,{children:"all"})," and ",(0,r.jsx)(t.code,{children:"any"})," have not been set."]})]})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"event-filter",children:"Event Filter"}),"\n",(0,r.jsx)(t.p,{children:"An event filter is a mechanism used to selectively process or handle events based\non predefined criteria, such as event type, source, or specific attributes."}),"\n",(0,r.jsx)(t.h4,{id:"event-filter-properties",children:"Properties"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Type"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Required"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"with"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.a,{href:"#event-properties",children:(0,r.jsx)(t.code,{children:"eventProperties"})})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"yes"})}),(0,r.jsx)(t.td,{children:"A name/value mapping of the attributes filtered events must define. Supports both regular expressions and runtime expressions."})]})})]}),"\n",(0,r.jsx)(t.h3,{id:"event-properties",children:"Event Properties"}),"\n",(0,r.jsxs)(t.p,{children:["An event object typically includes details such as the event type, source, timestamp,\nand unique identifier along with any relevant data payload. The\n",(0,r.jsx)(t.a,{href:"https://cloudevents.io/",children:"Cloud Events specification"}),", favoured by Serverless\nWorkflow, standardizes this structure to ensure interoperability across different\nsystems and services."]}),"\n",(0,r.jsx)(t.h4,{id:"event-properties-properties",children:"Properties"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Type"}),(0,r.jsx)(t.th,{style:{textAlign:"center"},children:"Required"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"id"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"string"})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"yes"})}),(0,r.jsx)(t.td,{children:"This is the name of the Temporal event"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"type"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"string"})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"yes"})}),(0,r.jsxs)(t.td,{children:["Describes the type of event related to the originating occurrence - either ",(0,r.jsx)(t.code,{children:"query"}),", ",(0,r.jsx)(t.code,{children:"signal"})," or ",(0,r.jsx)(t.code,{children:"update"}),".",(0,r.jsx)("br",{}),(0,r.jsxs)(t.em,{children:["Required when emitting an event using ",(0,r.jsx)(t.code,{children:"emit.event.with"}),"."]})]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"data"}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"any"})}),(0,r.jsx)(t.td,{style:{textAlign:"center"},children:(0,r.jsx)(t.code,{children:"no"})}),(0,r.jsxs)(t.td,{children:["The event payload. Ignored for ",(0,r.jsx)(t.code,{children:"query"}),"."]})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"query",children:"Query"}),"\n",(0,r.jsx)(t.p,{children:"A query is used to perform a read query on a running workflow. This makes no\nchanges to the workflow and is typically used to return the state, such as\nprogress"}),"\n",(0,r.jsx)(t.h3,{id:"query-example",children:"Example"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",children:"document:\n  dsl: 1.0.0\n  namespace: zigflow\n  name: query\n  version: 0.0.1\ndo:\n  - queryState:\n      listen:\n        to:\n          one:\n            with:\n              # ID maps to the query name in Temporal\n              id: get_state\n              type: query\n              # This data will be returned as-is\n              data:\n                id: ${ $data.id }\n                progress: ${ $data.progressPercentage }\n                status: ${ $data.status }\n  - createState:\n      output:\n        as:\n          data: ${ . }\n      set:\n        id: ${ uuid }\n        status: not started\n        progress: 0\n  - wait:\n      wait:\n        seconds: 5\n  - updateState:\n      set:\n        progress: 50\n        status: running\n  - wait:\n      wait:\n        seconds: 5\n  - updateState:\n      set:\n        progress: 100\n        status: finished\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In this example, the state data will be returned to the query call, with the\n",(0,r.jsx)(t.code,{children:"progress"})," and ",(0,r.jsx)(t.code,{children:"status"})," being updated as the workflow progresses."]}),"\n",(0,r.jsx)(t.h2,{id:"signal",children:"Signal"}),"\n",(0,r.jsx)(t.p,{children:"A signal is used to perform a write query on a running workflow. This receives\nno response and is typically used to make fire-and-forget calls to a workflow."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",children:"document:\n  dsl: 1.0.0\n  namespace: zigflow\n  name: signal\n  version: 0.0.1\ndo:\n  - approveListener:\n      metadata:\n        timeout: 10s # Controls the AwaitWithTimeout timeout - defaults to 60s\n      listen:\n        to:\n          one:\n            with:\n              # ID maps to the signal name in Temporal - this blocks until received\n              id: approve\n              # Temporal signal - used to make write request\n              type: signal\n  - outputSignal:\n      export:\n        as: '${ $context + { response: . } }'\n      set:\n        # Get the data from the approveListener signal\n        signal: ${ $data.approveListener }\n  - wait:\n      # The wait returns nothing by default, so we have to\n      # tell it to output the context\n      output:\n        as: ${ $context }\n      wait:\n        seconds: 5\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"metadata.timeout"})," controls the length of time that the timeout waits. If\na signal is received within the time then it's not approved and times out."]}),"\n",(0,r.jsx)(t.h3,{id:"signal-example",children:"Example"}),"\n",(0,r.jsx)(t.h2,{id:"update",children:"Update"}),"\n",(0,r.jsx)(t.p,{children:"An update is used to perform read/writes queries on a running workflow. This\nmakes a write call, optionally validates the input and then returns a response."}),"\n",(0,r.jsx)(t.h3,{id:"update-example",children:"Example"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",children:"document:\n  dsl: 1.0.0\n  namespace: zigflow\n  name: updates\n  version: 0.0.1\ndo:\n  - callDoctor:\n      metadata:\n        timeout: 10s # Controls the AwaitWithTimeout timeout - defaults to 60s\n      listen:\n        to:\n          # Only progress after every update received\n          all:\n            - with:\n                # ID maps to the update name in Temporal\n                id: temperature\n                # Temporal update - used to make read/write request\n                type: update\n                acceptIf: ${ $data.temperature > 38 }\n            - with:\n                id: bpm\n                type: update\n                acceptIf: ${ $data.bpm < 60 or $data.bpm > 100 }\n  - wait:\n      output:\n        as:\n          temperature: ${ $data.temperature }\n          bpm: ${ $data.bpm }\n      wait:\n        seconds: 10\n"})}),"\n",(0,r.jsxs)(t.p,{children:["As with the ",(0,r.jsx)(t.a,{href:"#signal",children:"signal"}),", this has a timeout. This has to receive both a\n",(0,r.jsx)(t.code,{children:"temperature"})," update greater than ",(0,r.jsx)(t.code,{children:"38"})," and a ",(0,r.jsx)(t.code,{children:"bpm"})," update below ",(0,r.jsx)(t.code,{children:"60"})," or above\n",(0,r.jsx)(t.code,{children:"100"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453(e,t,n){n.d(t,{R:()=>l,x:()=>d});var s=n(6540);const r={},i=s.createContext(r);function l(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);