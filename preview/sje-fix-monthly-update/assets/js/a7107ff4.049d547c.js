"use strict";(globalThis.webpackChunkzigflow=globalThis.webpackChunkzigflow||[]).push([[3665],{8453(e,n,t){t.d(n,{R:()=>o,x:()=>i});var s=t(6540);const r={},l=s.createContext(r);function o(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(l.Provider,{value:n},e.children)}},9528(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"dsl/tasks/fork","title":"Fork","description":"Allows workflows to execute multiple subtasks concurrently, enabling parallel","source":"@site/docs/dsl/tasks/fork.md","sourceDirName":"dsl/tasks","slug":"/dsl/tasks/fork","permalink":"/preview/sje-fix-monthly-update/docs/dsl/tasks/fork","draft":false,"unlisted":false,"editUrl":"https://github.com/mrsimonemms/zigflow/tree/main/docs/docs/dsl/tasks/fork.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dslSidebar","previous":{"title":"For","permalink":"/preview/sje-fix-monthly-update/docs/dsl/tasks/for"},"next":{"title":"Listen","permalink":"/preview/sje-fix-monthly-update/docs/dsl/tasks/listen"}}');var r=t(4848),l=t(8453);const o={},i="Fork",a={},c=[{value:"Properties",id:"properties",level:2},{value:"Example",id:"example",level:2},{value:"Non-competing Fork",id:"non-competing-fork",level:3},{value:"Competing Fork",id:"competing-fork",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"fork",children:"Fork"})}),"\n",(0,r.jsx)(n.p,{children:"Allows workflows to execute multiple subtasks concurrently, enabling parallel\nprocessing and improving the overall efficiency of the workflow. By defining a\nset of subtasks to perform concurrently, the Fork task facilitates the execution\nof complex operations in parallel, ensuring that multiple tasks can be executed\nsimultaneously."}),"\n",(0,r.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Name"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Type"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Required"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"fork.branches"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:(0,r.jsx)(n.a,{href:"./intro",children:(0,r.jsx)(n.code,{children:"map[string, task]"})})}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:(0,r.jsx)(n.code,{children:"no"})}),(0,r.jsxs)(n.td,{children:["The tasks to perform concurrently. These will be run as ",(0,r.jsx)(n.a,{href:"https://docs.temporal.io/child-workflows",children:"child workflows"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"fork.compete"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:(0,r.jsx)(n.code,{children:"boolean"})}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:(0,r.jsx)(n.code,{children:"no"})}),(0,r.jsxs)(n.td,{children:["Indicates whether or not the concurrent ",(0,r.jsx)(n.a,{href:"./intro",children:(0,r.jsx)(n.code,{children:"tasks"})})," are racing against each other, with a single possible winner, which sets the composite task's output.",(0,r.jsx)("br",{}),(0,r.jsxs)(n.em,{children:["If set to ",(0,r.jsx)(n.code,{children:"false"}),", the task returns an array that includes the outputs from each branch, preserving the order in which the branches are declared."]}),(0,r.jsx)("br",{}),(0,r.jsxs)(n.em,{children:["If to ",(0,r.jsx)(n.code,{children:"true"}),", the task returns only the output of the winning branch."]}),(0,r.jsx)("br",{}),(0,r.jsxs)(n.em,{children:["Defaults to ",(0,r.jsx)(n.code,{children:"false"}),"."]})]})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.h3,{id:"non-competing-fork",children:"Non-competing Fork"}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"This is the default behaviour."})}),"\n",(0,r.jsx)(n.p,{children:"This will return all the workflow."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"document:\n  dsl: 1.0.0\n  namespace: zigflow\n  name: example\n  version: 0.0.1\ndo:\n  - raiseAlarm:\n      # A fork is a series of child workflows running in parallel\n      output:\n        # Add output to context without the `multiStep` key\n        as:\n          raiseAlarm: '${ $context + del(.multiStep) }'\n      fork:\n        # If not competing, all tasks will run to the finish - this is the default behaviour\n        compete: false\n        branches:\n          # A single step is passed in by the Serverless Workflow task\n          - callNurse:\n              call: http\n              with:\n                method: get\n                endpoint: https://jsonplaceholder.typicode.com/users/2\n          # Multiple steps can be passed in by the Serverless Workflow do task\n          - multiStep:\n              do:\n                - wait1:\n                    wait:\n                      seconds: 3\n                - wait2:\n                    wait:\n                      seconds: 2\n          # Another single step child workflow\n          - callDoctor:\n              call: http\n              with:\n                method: get\n                endpoint: ${ \"https://jsonplaceholder.typicode.com/users/\" + ($input.userId | tostring) }\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This will output an object similar to this, with the workflow data under the\n",(0,r.jsx)(n.code,{children:"raiseAlarm"})," key:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "raiseAlarm": {\n    "callDoctor": {\n      // The workflow\'s data\n    },\n    "callNurse": {\n      // The workflow\'s data\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"competing-fork",children:"Competing Fork"}),"\n",(0,r.jsxs)(n.p,{children:["This will return the fastest returning workflow only. Simply change ",(0,r.jsx)(n.code,{children:"compete: false"}),"\nto ",(0,r.jsx)(n.code,{children:"compete: true"}),". The data will look similar to this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "raiseAlarm": {\n    // The workflow\'s data\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Unlike the non-competing version, the ",(0,r.jsx)(n.code,{children:"raiseAlarm"})," object will ",(0,r.jsx)(n.em,{children:"ONLY"})," contain\nthe data of the winning fork. All the other workflows will be cancelled and any\ndata generated will be discarded."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);